package com.rayrobdod.deductionTactics

import scala.swing.event.Event
import scala.collection.immutable.{Seq => ISeq, Set}
import scala.collection.mutable.{Seq => MSeq}
import scala.collection.JavaConversions.iterableAsScalaIterable
import com.rayrobdod.util.services.{ResourcesServiceLoader, Services}
import com.rayrobdod.commaSeparatedValues.parser.{CSVParser, ToSeqSeqCSVParseListener, CSVPatterns}
import com.rayrobdod.javaScriptObjectNotation.parser.listeners.ToSeqJSONParseListener
import com.rayrobdod.javaScriptObjectNotation.parser.JSONParser
import com.rayrobdod.boardGame.RectangularField
import com.rayrobdod.boardGame.mapValuesFromObjectNameToSpaceClassConstructor
import java.io.InputStreamReader
import com.rayrobdod.boardGame.Moved
import scala.parallel.Future

/**
 * An object that deals with Maps
 * 
 * @version 28 Nov 2012
 */
// metadata
object Maps
{
	private val SERVICE = "com.rayrobdod.deductionTactics.Maps"
	
	val names:ISeq[String] = {
		ISeq.empty ++ new ResourcesServiceLoader(SERVICE);
//		ISeq.empty ++ Services.readServices(SERVICE)
	}
	
	def getMap(index:Int):RectangularField = {
		val fieldFileName:String = Maps.names(index);
		
		val letterToNameMapReader = new InputStreamReader(this.getClass().getResourceAsStream("/com/rayrobdod/deductionTactics/letterMapping.json"))
		val letterToNameMap:Map[String,String] = {
			val listener = new ToSeqJSONParseListener()
			JSONParser.parse(listener, letterToNameMapReader)
			listener.resultMap.mapValues{_.toString}
		}
		val letterToSpaceClassConsMap = mapValuesFromObjectNameToSpaceClassConstructor(letterToNameMap)
		
		val fieldLetterReader = new InputStreamReader(this.getClass().getResourceAsStream("/" + fieldFileName + ".csv"))
		
		val fieldLetterTable:ISeq[ISeq[String]] = {
			val listener = new ToSeqSeqCSVParseListener()
			new CSVParser(CSVPatterns.commaDelimeted).parse(listener, fieldLetterReader)
			listener.result
		}
		val fieldSpaceClassConsTable = fieldLetterTable.map{
				_.map{letterToSpaceClassConsMap}}
		
		RectangularField.applySCC(fieldSpaceClassConsTable)
	}
	
	def possiblePlayers(index:Int):Set[Int] = {
		val fieldFileName:String = Maps.names(index);
		val spaceMapReader = new InputStreamReader(
				this.getClass().getResourceAsStream(
						"/" + fieldFileName + ".json"))
		val spaceMap:Map[String,Any] = {
			val listener = new ToSeqJSONParseListener()
			JSONParser.parse(listener, spaceMapReader)
			listener.resultMap
		}
		spaceMap.keySet.map{ Integer.parseInt(_) }
	}
	
	def startingPositions(index:Int, numPlayers:Int):ISeq[ISeq[(Int, Int)]] = {
		def asInt(any:Any):Int = {any match {
			case x:Int => x
			case x:Integer => x
			case x:Long => x.toInt
			case x:String => Integer.parseInt(x)
			case x:Any =>  Integer.parseInt(x.toString)
		}}
		
		val fieldFileName:String = Maps.names(index);
		val spaceMapReader = new InputStreamReader(
				this.getClass().getResourceAsStream(
						"/" + fieldFileName + ".json"))
		val spaceMap:Map[String,ISeq[ISeq[(Int, Int)]]] = {
			val listener = new ToSeqJSONParseListener()
			JSONParser.parse(listener, spaceMapReader)
			listener.resultMap.mapValues{_ match {
				case x:ISeq[_] => x.map{_ match {
					case y:ISeq[_] => y.map{_ match {
						case ISeq(i:Any, j:Any) => {
							((asInt(i), asInt(j)))
						}
					}}
				}}
			}}
		}
		spaceMap(numPlayers.toString)
	}
}